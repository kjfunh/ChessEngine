const { Chess } = require('./chess.js');

function getPieceVal(piece)
{
    // Value assignment
    if (piece === null) {
        return 0;
    }
    var pieceValues = {p:10, n:30, r:50, b:30, q:90, k:1000};
    var value = 0;
    var pieceLowerCase = piece.type.toLowerCase();
    if (pieceLowerCase in pieceValues)
    {
        value = pieceValues[pieceLowerCase];
    }
    return value;
}

// Evaluate board value for the current player
// player = "b" or "w"
function evaluateBoard(game, player)
{
    let board = game.board()
    if(game.in_checkmate())
    {
        if (game.turn() === player)
        {
            return -1000000;
        }
        else
        {
            return 1000000;
        }
    }
    let totalScore = 0;
    // Evaluate 8*8 position on board:
    for(var i = 0; i < 8; i++)
    {
        for(var j = 0; j <8; j ++)
        {
            piece = board[i][j];
            if (piece !== null)
            {
                pieceValue = getPieceVal(piece);
                if(piece.color === player)
                {
                    totalScore = totalScore + pieceValue;
                }
                else{
                    totalScore = totalScore - pieceValue;
                }
            }
        }
    }
    return totalScore;
}

// Game is chessjs.game object
// Turn is 0 or 1, 0 being the same as the player we are maximizing and 1 being the opponent
// Max depth can be set depending on how far we can go before timeout
// cur_depth is current traversal depth
function MinMaxSearch(game, player, turn, max_depth, cur_depth, alpha, beta)
{
    // Max search depth, return board evaluation value
    if(cur_depth == max_depth)
    {
        return evaluateBoard(game, player);
    }
    let moves = game.moves();
    // Maximize
    if(turn == 0)
    {
        let bestValue = -1000000;
        for(let i = 0; i < moves.length; i++)
        {
            game.move(moves[i]);
            let curValue = MinMaxSearch(game, player, 1 - turn, max_depth, cur_depth + 1);
            game.undo();
            bestValue = Math.max(bestValue, curValue);
            alpha = Math.max(alpha, bestValue);
            if (alpha >= beta)
            {
                break;
            }
            
        }
        return bestValue;
    }
    // Minimize
    else
    {
        let bestValue = 1000000;
        for(let i = 0; i < moves.length; i++)
        {
            game.move(moves[i]);
            let curValue = MinMaxSearch(game, player, 1 - turn, max_depth, cur_depth + 1);
            game.undo();
            bestValue = Math.min(curValue, bestValue);
            beta = Math.min(beta, bestValue);
            if (beta <= alpha)
            {
                break;
            }            
        }
        return bestValue;
    }
}

function getBestMove(game_input, player)
{
    let game = Object.create(game_input);
    let moves = game.moves();
    let bestValue = -1000000;
    let bestIndex = 0;
    let alpha = -Infinity
    let beta = Infinity
    for(let i = 0; i < moves.length; i++)
    {
        game.move(moves[i]);
        let curValue = MinMaxSearch(game, player, 1, 2, 0, alpha, beta)
        game.undo()
        if(curValue > bestValue)
        {
            bestValue = curValue;
            bestIndex = i;
        }
        alpha = Math.max(alpha, bestValue);
        if (alpha >= beta)
        {
            break;
        }
    }
    return moves[bestIndex];
}


const chess = new Chess();


while (!chess.game_over()) {
    let bestMove = getBestMove(chess, chess.turn());
    chess.move(bestMove)
    console.log(chess.ascii())
};

/*
chess.move('a3')
console.log(chess.ascii())
chess.move('Nc6')
console.log(chess.ascii())*/

